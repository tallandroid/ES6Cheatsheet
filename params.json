{
  "name": "Es6cheatsheet",
  "tagline": "CheatSheet for learning ES6 from MDN",
  "body": "# ES6Cheatsheet\r\n\r\nCheatSheet created from [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide).\r\n\r\n===================\r\n\r\n## Functions\r\n[Reference](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions)\r\n### Rest Parameters \r\n* Remove the boilerplate code:\r\n```\r\nfunction x(a,b,c){\r\n var args = Array.prototype.slice.call(arguments);\r\n \r\n}\r\n```\r\nConsume like this :\r\n```\r\nfunction x(...thisArgs){\r\n console.log(...thisArgs instanceof Array); //true\r\n }\r\n```\r\n*Note: Not implemented in Chrome yet - Lookup browser compatibility*\r\n\r\n### Lazy getters\r\nAllows you to execute a custom procedure when the property is accessed. Optimized to **memoize** the value calculated(**Maybe only Gecko**)\r\n\r\n```\r\nvar obj = {\r\n  get a():{\r\n    console.log(\"hoodibaba\");\r\n  },\r\n  get service():{\r\n    return new function(){\r\n      //not sure how the scope wil work here    \r\n    }\r\n  },\r\n  get [expr]:{\r\n    //properties can be evaluated as an expression too\r\n  }\r\n}\r\n//obj.a = hoodibaba\r\n//obj.service = //no idea\r\n```\r\n\r\n=================\r\n\r\n### Setters\r\nNot sure if they will find any use. Looking for a possible use cases. \r\n\r\n=================\r\n\r\n### Function declaration vs Function expression vs Function constructor\r\n- **Function declaration**\r\n```function foo(){}```\r\n- **Function expression** \r\n``` var x = function foo(){}```\r\n- function expression creates a closure vs *Function* inherits only global scope\r\n- function declaration and function expression are parsed only once\r\n- function expression gives you a way to create private functions\r\n- declaration and expression can be used interchangeable as apart from hoisting , I dont see any difference. **Need verification**\r\n- in strict mode starting with es6 , the block level functions are restricted to that block only. Dont use non-strict mode with es6.\r\n\r\n==================\r\n\r\n### Arrow functions\r\n- The most awesome feature ever! \r\n- Removes the pain of this\r\n- Jargonly - arrow functions get executed in the enclosing scope . They dont have a new scope.\r\n\r\n```\r\n$(\"randomeElement\").click(function(event){\r\n  //some random shit here\r\n});\r\n```\r\ncan be replaced with \r\n\r\n```$(\"randomElement\").click(event => //some random shit here)```\r\n\r\n- **Catch**\r\n  - multiple parameters should be enclosed in brackets\r\n  ```\r\n  ((x, y, z) => a)\r\n  ```\r\n  - if function is a block , it should have an explicit return statement\r\n  - if function returns an empty object , it should be enclosed in brackets\r\n  ```\r\n  x => ({})\r\n  ```\r\n- **Thumbrule**\r\n  - use function expression or declaration for methods callable using ```object.method()``` way\r\n  - for everything else , use arrow functions(THIS IS AWESOME!!!)\r\n  \r\n==================",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}